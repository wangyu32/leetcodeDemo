# 最大数

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

**示例 1:**

```
输入: [10,2]
输出: 210
```

**示例 2:**

```
输入: [3,30,34,5,9]
输出: 9534330
```

**说明:** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

```java
class Solution {
    public String largestNumber(int[] nums) {
        /*
          思路：想要组成的数最大，一定是大的数字在前面，依次应该拼接9开头的，8开头的、至1开头的；将以相同数字开头的顺序（由大到小）；
                依次将1-9分组的数据按9-1的顺序将组内数据拼接。
          难点：1.以相同数字开头的一组数据排序，比如12，121，123这两数字如何组合才最大？采用冒泡排序的方式先取2个数值比较拼接后哪个大，
                找到遍历一遍之和找到最大的再在剩余中找到最大的（或者依次找最小的）
                2.如何更快的算出2个数拼接之和谁在前面大？方法：a * (10^b长度) + b 与 b * (10^a长度) + a 比大小即可
          步骤：1.遍历数组，把1至9开头的数字分别分组
               2.步骤1中每组数字都是1-9中一个数字开头的排序。
               3.拼接
          补充：在步骤1之前加入数组内0元素的处理，当都是0时，直接返回0
         */
        if(nums == null || nums.length == 0){
            return "";
        }

        if(nums.length == 1){
            return String.valueOf(nums[0]);
        }

        //key是1-9数字，value是key开头的所有数字
        Map<Integer, List<Integer>> map = new HashMap<>();
        int zeroCount = 0;//零元素个数
        for (int i = 0; i < nums.length; i++) {
            int temp = nums[i];
            if(temp == 0){
                zeroCount ++;
                continue;
            }
            int num = nums[i];
            while (temp > 9){
                temp /= 10;
            }
            int firstNumber = temp;//数字的最高位即第一个数字
            List<Integer> list = map.get(firstNumber);
            if(list == null){
                list = new ArrayList<>();
                list.add(num);
                map.put(firstNumber, list);
            } else {
                list.add(num);
            }
        }

        if(zeroCount == nums.length){
            //全是0的情况
            return "0";
        }

        //对map里每组数字排序，
        StringBuilder sb = new StringBuilder();

        for (int i = 9; i > 0; i--) {
            List<Integer> list = map.get(i);
            if(list == null || list.size() == 0){
                continue;
            }

            if(list.size() == 1){//只有1个数值不用排序
                sb.append(list.get(0));
                continue;
            }

            //转换成数组
            int[] array = new int[list.size()];
            for (int k = 0; k < list.size(); k++) {
                array[k] = list.get(k);
            }

            //9-1顺序每组内部依次排序
            sortForLargestNumber(array);

            if(array != null && array.length > 0){
                for (int j = 0; j < array.length; j++) {
                    sb.append(array[j]);
                }
            }
        }

        //最后面补充0
        while (zeroCount > 0){
            sb.append("0");
            zeroCount--;
        }
        return sb.toString();
    }

    //array数组内数字拼接结果由大到小排序
    private void sortForLargestNumber(int[] array) {
        //冒泡排序的方式比大小，数据量大时可使用快速排序
        int len = array.length;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - 1 - i; j++) {
                if (compareForLargestNumber(array[j+1], array[j])) {
                    swap(array, j, j + 1);
                }
            }
        }
    }

    //判断a,b两个数字拼接结果ab是否大于ba
    private boolean compareForLargestNumber(int a, int b) {
        if (a == b)
            return false;
        int temp = a;
        int aLen = 1;//a的长度
        while (temp > 9) {
            temp /= 10;
            aLen++;
        }
        temp = b;
        int bLen = 1;//b的长度
        while (temp > 9) {
            temp /= 10;
            bLen++;
        }
        long ab = a * powLong(10, bLen) + b;//使用long避免越界
        long ba = b * powLong(10, aLen) + a;//使用long避免越界
        return ab > ba;
    }

    private void swap(int a[], int i, int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    private long powLong(int a, int b){
        if(b == 0)
            return 1;

        long c = 1;
        while (b > 0){
            c *= a;
            b--;
        }
        return c;
    }
}
```

# 直线上最多的点数

给定一个二维平面，平面上有 *n* 个点，求最多有多少个点在同一条直线上。

**示例 1:**

```
输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
```

**示例 2:**

```
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
```

```java
    public int maxPoints(int[][] points) {
        // 参考答案，大神解法 https://leetcode-cn.com/submissions/detail/21884618/
        // 如果总坐标点少于 3 个，直接返回答案
        int n = points.length;
        if (points.length <= 2) return n;

        // 搜索直线上最多的点数
        int max = 0;
        for (int i = 0; i < n; i ++) {
            // same 表示有多少个和 i 一样的点
            int same = 1;
            for (int j = i + 1; j < n; j ++) {
                // cnt 表示除了 i 坐标点外，有多少个点在 i、j 坐标点构成的直线上
                int cnt = 0;
                if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                    // i、j 是重复点，计数
                    same ++;
                } else {
                    // i、j 不是重复点，检查其他点是否在这条直线上，j 坐标点也在这条直线上，所以 cnt ++
                    cnt ++;
                    long xDiff = (long)(points[i][0] - points[j][0]);
                    long yDiff = (long)(points[i][1] - points[j][1]);
                    for (int k = j + 1; k < n; k ++) {
                        if (xDiff * (points[i][1] - points[k][1]) == yDiff * (points[i][0] - points[k][0])) {
                            cnt ++;
                        }
                    }
                }
                // 最大值比较
                max = Math.max(max, cnt + same);
            }
        }
        return max;
    }

    public int maxPoints3(int[][] points) {
        /**
         * 161 ms > 8%
         * 参考学习，https://blog.csdn.net/qq_41231926/article/details/81475442
         * 思路：用分数形式存储直线的斜率，切勿忘记斜率不存在的情况
         * （1）新建一个长度为点的数量的数组count，用以保存对于每一个点i其斜率存在的情况下的直线的经过的最多的点数。
         * （2）首先设置一个外循环依次遍历所有的点，外循环变量记为i。每一次循环都新建一个哈希表用以记录与i点在同一条直线上的直线的斜率以及该斜率直线下点的个数。再新建一个变量same，用以记录与点i在坐标平面上位置相同的点j的数量。还得新建一个变量size，用以记录经过点i且垂直于x轴（即斜率不存在）的直线的情况。
         * （3）再设置一个内循环依次遍历所有的点，内循环变量记为j。
         * （4）如果遍历到的点满足i ！= j，说明遍历到的不是同一个点，那么我们就需要来判断点j和点i是否在同一条直线上。由数学基本知识可知，平面上的一点以及相应的斜率就可以确定一条直线。
         * （5）当点i的x坐标与点j的x坐标不相等时，点i和点j的斜率是存在的。由于直接求斜率会产生误差，LeetCode上的一些测试用例不能通过。因此我们计算其分数形式表示的斜率，即dy/dx，其中dy为点i和点j的y坐标的差值，dx为点i和点j的x坐标的差值。另外，我们需要把分数dy/dx化简到不能约分的形式，防止4/2和2/1这两条斜率明明相同的直线却被视作两条直线的情况出现。需要保存两个变量dy和dx，可以用一个长度为2的整型数组nums来保存，其中nums[0]保存dy，nums[1]保存dx。如果（1）中新建的哈希表中已经保存了nums的值，那么相应nums对应的值+1即可；否则，在哈希表中新增一个键nums，其值为1。
         * （6）在（4）中我们说需要对dy/dx进行约分处理，那么我们就需要一个函数来求dy和dx的最大公约数gcd，令dy = dy / gcd，dx = dx / gcd。该函数其实很简单，我们可以用欧几里得算法递归地求解，公式为gcd(a, b) = gcd(b, a mod b)。
         * （7）如果点i的x坐标与点j的x坐标相等，这又可以分为两种情况。
         * a.如果点i的y坐标和点j的y坐标也相等，那么说明点i和点j的点在坐标平面上是同一个点，那么我们需要same++，同时垂直于x轴的直线的数量需要size++。
         * b.如果点i的y坐标和点j的y坐标不相等，我们只需要对垂直于x轴的直线的数量进行加1处理。
         * （8）对于每一个点i，经过点i且经过点数最多的直线应该在size和（same + count[i]）中取最大值。
         * （9）遍历一遍count数组，求得其最大值返回即可。
         */
        int n = points.length;
        if(0 == n) {
            return 0;
        }
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            count[i] = 1;
            int size = 1;
            int same = 0;
            HashMap<Integer[], Integer> hashMap = new HashMap<>();
            for (int j = 0; j < n; j++) {
                if(i != j) {
                    if(points[i][0] != points[j][0]) {
                        int dy = points[i][1] - points[j][1];
                        int dx = points[i][0] - points[j][0];
                        int gcd = gcd(dy, dx);
                        if(0 != gcd) {
                            dy = dy /gcd;
                            dx = dx / gcd;
                        }
                        Integer[] nums = new Integer[2];
                        nums[0] = dy;
                        nums[1] = dx;
                        boolean flag = false;
                        for (Integer[] array : hashMap.keySet()) {
                            if(nums[0] == array[0] && nums[1] == array[1]) {
                                flag = true;
                                hashMap.put(array, hashMap.get(array) + 1);
                            }
                        }
                        if(!flag) {
                            hashMap.put(nums, 1);
                        }
                    }else {
                        if(points[i][1] == points[j][1]) {
                            same++;
                        }
                        size++;
                    }
                }
            }
            for (Integer[] array : hashMap.keySet()) {
                if(hashMap.get(array) + 1 > count[i]) {
                    count[i] = hashMap.get(array) + 1;
                }
            }
            count[i] += same;
            count[i] = Math.max(count[i], size);
        }
        int maxIndex = 0;
        for (int i = 1; i < n; i++) {
            if(count[i] > count[maxIndex]) {
                maxIndex = i;
            }
        }
        return count[maxIndex];
    }

    //求x,y的最大公约数
    private int gcd(int x, int y) {
        if (y == 0)
            return x;
        return gcd(y, x % y);
    }

    public int maxPoints2(int[][] points) {
        //稍微优化，却发生超时，之前提交的也超时了，怀疑服务器忙
        if(points == null || points.length == 0){
            return 0;
        }

        if(points.length == 1){
            return 1;
        }

        //第一条线
        long[] line1 = linearEquationInTwoUnknowns(points[0], points[1]);
        Map<long[], Set<int[]>> allLineMap = new HashMap<>();//key为线，value是点集合
        Set<int[]> set = new HashSet<>();//某线上所有点集合
        set.add(points[0]);
        set.add(points[1]);
        allLineMap.put(line1, set);

        int totalPoint = points.length;
        int mostPointLineTotal = 2;
        int secondPointLineTotal = 0;

        for (int i = 2; i < points.length; i++) {
            int remainderPoint = totalPoint - i - 1;//剩余点
            int[] point = points[i];//当前点
            Set<int[]> inLinePointSet = new HashSet<>();//与point在同一直线的所有点
            for(long[] line : allLineMap.keySet()){
                Set<int[]> linePointsSet = allLineMap.get(line);//当前线上所有点
                if(pointInLine(point, line)){
                    inLinePointSet.add(point);
                    linePointsSet.add(point);
                }
                if(linePointsSet.size() > mostPointLineTotal){
                    mostPointLineTotal = linePointsSet.size();
                }

                if(linePointsSet.size() > secondPointLineTotal && linePointsSet.size() < mostPointLineTotal){
                    secondPointLineTotal = linePointsSet.size();
                }
            }

            if(secondPointLineTotal > 0 && ((remainderPoint + secondPointLineTotal) < mostPointLineTotal)){
                //当剩余点加上包含点数第二多的线的点数小于包含点最多的线的点数时，意味着即使后面的点加到第二多的线上，也无法超越
                //目前点最多的线，那么只需要判断剩余点中有多少个在当前对多的点数上即可
                continue;
            }

            for (int j = 0; j < i; j++) {
                int[] pointTemp = points[j];
                if(!containsPoint(inLinePointSet, pointTemp)){
                    //与point不在一条线上的点，需要与之连线
                    long[] lineNew = linearEquationInTwoUnknowns(point, pointTemp);
                    for(long[] line0 : allLineMap.keySet()){
                        if(isSameLine(lineNew, line0)){
                            lineNew = line0;
                            break;
                        }
                    }

                    Set<int[]> set0 = allLineMap.get(lineNew);
                    if(set0 == null){
                        set0 = new HashSet<>();
                        set0.add(point);
                        set0.add(pointTemp);
                        allLineMap.put(lineNew, set0);
                    } else {
                        set0.add(point);
                        set0.add(pointTemp);
                    }
                }
            }
        }
        int max = 0;

        for(Set<int[]> pointsSet : allLineMap.values()){
            if(pointsSet.size() > max){
                max = pointsSet.size();
            }
        }

        return max;
    }

    public int maxPoints1(int[][] points) {
        //862 ms 测试通过
        if(points == null || points.length == 0){
            return 0;
        }

        if(points.length == 1){
            return 1;
        }

        //第一条线
        long[] line1 = linearEquationInTwoUnknowns(points[0], points[1]);
        Map<long[], Set<int[]>> allLineMap = new HashMap<>();//key为线，value是点集合
        Set<int[]> set = new HashSet<>();//某线上所有点集合
        set.add(points[0]);
        set.add(points[1]);
        allLineMap.put(line1, set);
        for (int i = 2; i < points.length; i++) {
            int[] point = points[i];//当前点
            Set<int[]> inLinePointSet = new HashSet<>();//与point在同一直线的所有点
            for(long[] line : allLineMap.keySet()){
                Set<int[]> linePointsSet = allLineMap.get(line);//当前线上所有点
                if(pointInLine(point, line)){
                    inLinePointSet.add(point);
                    linePointsSet.add(point);
                }
            }

            for (int j = 0; j < i; j++) {
                int[] pointTemp = points[j];
                if(!containsPoint(inLinePointSet, pointTemp)){
                    //与point不在一条线上的点，需要与之连线
                    long[] lineNew = linearEquationInTwoUnknowns(point, pointTemp);
                    for(long[] line0 : allLineMap.keySet()){
                        if(isSameLine(lineNew, line0)){
                            lineNew = line0;
                            break;
                        }
                    }

                    Set<int[]> set0 = allLineMap.get(lineNew);
                    if(set0 == null){
                        set0 = new HashSet<>();
                        set0.add(point);
                        set0.add(pointTemp);
                        allLineMap.put(lineNew, set0);
                    } else {
                        set0.add(point);
                        set0.add(pointTemp);
                    }
                }
            }
        }
        int max = 0;

        for(Set<int[]> pointsSet : allLineMap.values()){
            if(pointsSet.size() > max){
                max = pointsSet.size();
            }
        }

        return max;
    }

    //判断pointTemp是否与inLinePointSet里的点有重复
    private boolean containsPoint(Set<int[]> inLinePointSet, int[] pointTemp) {
        for(int[] point : inLinePointSet){
            if(isSamePoint(point, pointTemp)){
                return true;
            }
        }
        return false;
    }

    //是否是相同的点
    private boolean isSamePoint(int[] point1, int[] point2){
        return point1[0] == point2[0] && point1[1] == point2[1];
    }

    //通过a点[x1,y1]2个未知数的线性方程，即二元一次方程
    private long[] linearEquationInTwoUnknowns(int[] a, int[] b){
        /*
            y = kx + b
            a = [x1, y1]
            b = [x2, y2]
         => k = (y1-y2) / (x1-x2)
            b = (x2y1 - x1y2) / (x2 - x1)
         */
        long[] line = null;

        if(a[0] == b[0] && a[1] != b[1]){
            line = new long[1];//长度为1，表示直线垂直x轴
            line[0] = a[0];//对应方程x=a[0]
        } else if(a[0] != b[0] && a[1] == b[1]){
            line = new long[2];//长度为2，表示直线垂直y轴
            line[1] = a[1];//对应方程y=a[1]
        } else {
            line = new long[4];
            line[0] = (long)a[1] - (long)b[1];//k的分子
            line[1] = (long)a[0] - (long)b[0];//k的分母
            line[2] = (long)b[0] * (long)a[1] - (long)a[0] * (long)b[1];//b的分子
            line[3] = (long)b[0] - (long)a[0];//b的分母
        }
        return line;
    }

    //计算point点[x,y]是否在线line上
    private boolean pointInLine(int[] point, long[] line){
        long x = point[0];
        long y = point[1];

        if(line.length == 1){
            return x == line[0];
        } else if (line.length == 2){
            return y == line[1];
        } else {
            //验证是否y = kx + b = x * line[0] / line[1] + line[2] / line[3]
            //换算 y * line[1] * line[3] = x * line[0] * line[3] + line[2]  * line[1]
            return y * line[1] * line[3] == x * line[0] * line[3] + line[2]  * line[1] ;
        }
    }

    //验证2条线是否是一条线
    private boolean isSameLine(long[] line1, long[] line2){
        //直线公式 y = kx + b
        if(line1.length != line2.length){
            return false;
        }

        if(line1.length == 1){
            return line1[0] == line2[0];
        }

        if(line1.length == 2){
            return line1[1] == line2[1];
        }

        if(line1[0] * line2[1] != line1[1] * line2[0]){
            //验证k是否相等
            return false;
        }

        if(line1[2] * line2[3] != line1[3] * line2[2]){
            //验证b是否相等
            return false;
        }
        return true;
    }


```

