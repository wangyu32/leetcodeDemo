# 快乐数

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

**示例:** 

```
输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

```java
	public boolean isHappy(int n) {
        //大神算法
        int total = everyPosNumQuadraticSum(n);
        while(total != 1 && total != 4){
            total = everyPosNumQuadraticSum(total);
        }
        return total == 1;
    }

    //中级-快乐数 方法1 比较笨的
    public boolean isHappy1(int n) {
        if(n == 1){
            return true;
        }
        int total = everyPosNumQuadraticSum(n);

        if(total == 1){
            return true;
        }
        Set<Integer> set = new HashSet<>();
        set.add(total);
        while(total != 1){
            total = everyPosNumQuadraticSum(total);
            if(!set.add(total)){
                return false;
            }
        }

        return true;
    }

    //每个位置数字平方和
    private int everyPosNumQuadraticSum (int n) {
        int b = 0;//除10商值
        int c = 0;//除10个位数
        int total = 0;
        while (n > 0){
            c = n % 10; //个位数
            total += c * c;
            n = n / 10;
        }
        return total;
    }
```

#  阶乘后的零

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

```java
	public int trailingZeroes(int n) {
        /**
         * 要求末尾有多少个零，则该数应为x*10k 的形式等于x*（2k *5k）
         * 也就是求该数分解质因子后有几个5就行，：如1*2*3*4*5=1*2*3*2*2*5（里面有一个5）所以结果为1个0
         */
        int sum = 0;
        while (n > 0) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
```

# Excel表列序号

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

**示例 1:**

```
输入: "A"
输出: 1
```

**示例 2:**

```
输入: "AB"
输出: 28
```

**示例 3:**

```
输入: "ZY"
输出: 701
```

**致谢：**
特别感谢 [@ts](http://leetcode.com/discuss/user/ts) 添加此问题并创建所有测试用例。

```java
	public int titleToNumber(String s) {
        // A - Z 对应asc码 65-90
        char[] array = s.toCharArray();
        int total = 0;
        int len = array.length;
        for (int i = 0; i < len; i++) {
            total += ((int)array[i] - 64) * pow(26, len - i - 1);
        }
        return total;
    }

    //求a的b次幂
    private int pow(int a, int b){
        if(b == 0)
            return 1;

        int c = 1;
        while (b > 0){
            c *= a;
            b--;
        }
        return c;
    }
```

# Pow(x, n)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

**说明:**

- -100.0 < *x* < 100.0
- *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

```java
	public double myPow(double x, int n) {
        if(x == 0)
            return 0D;
        if(n == 0)
            return 1D;
        if(n == 1)
            return x;
        if(n == -1)
            return 1 / x;

        //二分法
        if(n > 0){
            if(n % 2 == 1){
                double d = myPow(x, (n-1) / 2);
                return d * d * x;
            } else {
                double d = myPow(x, n / 2);
                return d * d;
            }
        } else {
            if(n % 2 == -1){
                double d = myPow(x, (n+1) / 2);
                return d * d / x;
            } else {
                double d = myPow(x, n / 2);
                return d * d;
            }
        }
    }

    //超时算发
    public double myPow1(double x, int n) {
        if(x == 0)
            return 0D;
        if(n == 0)
            return 1D;

        double c = 1.0D;
        if(n > 0){
            while (n > 0){
                c *= x;
                n--;
            }
        } else {
            while (n < 0){
                c /= x;
                n++;
            }
        }
        return c;
    }
```

# x 的平方根

实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

```java
	public int mySqrt(int x) {
        //牛顿迭代法
        if (x == 0) return 0;
        double res = 1, pre = 0;
        while ((res - pre) > 0 ? (res - pre) > 1e-6 : (pre - res) > 1e-6) { //手动指定一个精度
            pre = res;
            res = (res + x / res) / 2;
        }
        return (int)res;
    }

    //最快的
    public int mySqrtNewton2(int x) {
        //牛顿迭代法
        long res = x;
        while (res * res > x) {
            res = (res + x / res) / 2;
        }
        return (int)res;
    }

    public int mySqrtNewton1(int x) {
        //牛顿迭代法
        if (x == 0) return 0;
        double last = 0;
        double res = 1;
        while (res != last) { //使用double的精度
            last = res;
            res = (res + x / res) / 2;
        }
        return (int)res;
    }

    public int mySqrt1(int x) {
        //参考https://www.cnblogs.com/grandyang/p/4346413.html
        if (x <= 1)
            return x;
        int left = 0, right = x;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (x / mid >= mid)
                left = mid + 1;
            else
                right = mid;
        }
        return right - 1;
    }

    //Line 16: java.lang.StackOverflowError
    public int mySqrtWy(int x) {
        if(x == 0 || x == 1)
            return x;

        return mySqrt(1, x/2, x/2, x);
    }

    private int mySqrt(int start, int mid, int end, int x) {
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x)
            return mid;

        if(mid * mid > x){
            return mySqrt(start, (start + mid) / 2, mid, x);
        } else {
            return mySqrt(mid, end, end, x);
        }
    }
```

# 两数相除



给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

**示例 1:**

```
输入: dividend = 10, divisor = 3
输出: 3
```

**示例 2:**

```
输入: dividend = 7, divisor = -3
输出: -2
```

**说明:**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

```java
	public int divide(int dividend, int divisor) {
        //溢出情况
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }

        if(dividend == 0){
            return 0;
        }

        if(divisor == 0){
            return Integer.MAX_VALUE;
        }

        boolean flag = true; //dividend与divisor符号相同标志
        //由于Integer.MIN_VALUE的绝对值比Integer.MAX_VALUE大1，所以都采用负数计算可以避开边界溢出问题
        if (dividend > 0 && divisor < 0) {
            flag = false;
            dividend = 0 - dividend;
        } else if (dividend < 0 && divisor > 0) {
            flag = false;
            divisor = 0 - divisor;
        } else if (dividend > 0 && divisor > 0) {
            dividend = 0 - dividend;
            divisor = 0 - divisor;
        }
        int re = 0;
        while (dividend <= divisor) {
            long aa = 1;
            long temp = divisor;
            while (temp > dividend >> 1) {
                temp <<= 1;
                aa <<= 1;
            }
            dividend -= temp;
            re += aa;
        }

        if (!flag) {
            return 0 - re;
        }

        return re;
    }

    //正数算法，存在边界溢出情况
    public int divide2(int dividend, int divisor) {
        int re = 0;
        //被除数大于除数
        while (dividend >= divisor){
            int aa = 1;
            int temp = divisor;
            while (temp < dividend>>1){
                aa <<= 1;
                temp <<=1;
            }
            dividend -= temp;
            re+=aa;
        }
        return re;
    }

    //Line 7: java.lang.StackOverflowError
    public int divide1(int dividend, int divisor) {
        if (dividend < divisor)
            return 0;
        int sum = divisor;
        int result = 1;
        //二分法计算结果
        while (dividend >= (sum << 1)) {
            sum <<= 1;
            result <<= 1;
        }
        return result + divide1(dividend - sum, divisor);
    }

    //Line 7: java.lang.StackOverflowError
    public int divide0(int dividend, int divisor) {
        if (dividend < divisor)
            return 0;
        int sum = divisor;
        int result = 1;
        //二分法计算结果
        while (dividend >= (sum + sum)) {
            sum += sum;
            result += result;
        }
        return result + divide0(dividend - sum, divisor);
    }
```

# 分数到小数



给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

**示例 1:**

```
输入: numerator = 1, denominator = 2
输出: "0.5"
```

**示例 2:**

```
输入: numerator = 2, denominator = 1
输出: "2"
```

**示例 3:**

```
输入: numerator = 2, denominator = 3
输出: "0.(6)"
```

```java
	public static String fractionToDecimal(int numerator, int denominator) {
        long num = numerator;//防止溢出
        long den = denominator;
        if (den == 0) return "";
        if (num == 0) return "0";
        if (den == 1) return num + "";
        if (den == -1) return String.valueOf(0 - num);

        boolean nagetive = false;//num与den异号标志
        if (num > 0 && den < 0) {
            nagetive = true;
            den = 0 - den;
        } else if (num < 0 && den > 0) {
            nagetive = true;
            num = 0 - num;
        } else if (num < 0 && den < 0) {
            den = 0 - den;
            num = 0 - num;
        }

        StringBuilder sb1 = new StringBuilder();
        //是否异号
        if(nagetive)
            sb1.append("-");

        //整数部分
        sb1.append(num / den);

        //整除
        if(num % den == 0)
            return sb1.toString();

        sb1.append(".");
        num %= den;
        //除数是2或5时候的快速处理
        while (num != 0 && den % 2 == 0 || den % 5 == 0) {
            if (den % 10 == 0)
                den /= 10;
            else if (den % 2 == 0) {
                den /= 2;
                num *= 5;
            } else {
                den /= 5;
                num *= 2;
            }
            sb1.append(num / den);
            num %= den;
        }

        //整除
        if(num % den == 0)
            return sb1.toString();

        num %= den;

        long reminder = num;//余数
        StringBuilder sb2 = new StringBuilder();
        while (true) {
            reminder *= 10;
            sb2.append(reminder / den);
            reminder = reminder % den;
            if (reminder % den == 0 || reminder == num)
                break;
        }
        if (reminder % den == 0)
            return sb1.append(sb2).toString();
        else
            return sb1.append("(").append(sb2).append(")").toString();
    }

    //提交答案中网上大神的算法
    public static String fractionToDecimal4(int numerator, int denominator) {
        StringBuilder sb1 = new StringBuilder();
        if (numerator<0&&denominator>0) {
            sb1.append("-");
            numerator = -numerator;
        } else if(numerator>0&&denominator<0) {
            sb1.append("-");
            denominator = -denominator;
        } if(numerator<0&&denominator<0) {
            numerator = -numerator;
            denominator = -denominator;
        }
        sb1.append( numerator/denominator );
        if(numerator%denominator==0)
            return sb1.toString();
        sb1.append(".");
        numerator %= denominator;
        while(numerator!=0&&denominator%2==0||denominator%5==0) {
            if(denominator%10==0)
                denominator /= 10;
            else if(denominator%2==0) {
                denominator /= 2;
                numerator *= 5;
            } else {
                denominator /= 5;
                numerator *= 2;
            }
            sb1.append(numerator/denominator);
            numerator %= denominator;
        }
        if(numerator%denominator==0)
            return sb1.toString();
        numerator %= denominator;
        long reminder = numerator;
        StringBuilder sb2 = new StringBuilder();
        while(true) {
            reminder *= 10;
            sb2.append(reminder/denominator);
            reminder = reminder%denominator;
            if(reminder%denominator==0||reminder==numerator)
                break;
        }
        if(reminder%denominator==0)
            return sb1.append(sb2).toString();
        else
            return sb1.append("(").append(sb2).append(")").toString();
    }
    public static String fractionToDecimal3(int numerator, int denominator) {
        //5ms 参考 https://segmentfault.com/a/1190000003794677
        if (denominator == 0) {
            return "";
        }
        if (numerator == 0) {
            return "0";
        }
        long num = numerator;
        long den = denominator;
        // 判断结果正负号
        boolean negative = (num > 0 && den < 0) || (num < 0 && den > 0);
        num = Math.abs(num);
        den = Math.abs(den);
        // 得到整数部分
        String integ = (negative ? "-" : "") + String.valueOf(num / den);
        // 如果存在小数部分
        if(num % den != 0){
            num = num % den;
            HashMap<Long, Integer> map = new HashMap<Long, Integer>();
            int pos = 0;
            map.put(num, pos);
            StringBuilder frac = new StringBuilder();
            // 计算小数部分
            while(num != 0){
                // 先把算出的小数加上，再判断余数是否重复，如果余数重复的话，小数会从下一个开始重复
                num = num * 10;
                frac.append(num / den);
                num = num % den;
                // 如果该余数之前出现过，说明有循环，上次出现的位置到当前位置就是循环的部分
                if(map.containsKey(num)){
                    // 将非循环部分和循环部分分开
                    String pre = frac.substring(0, map.get(num));
                    String loop = frac.substring(map.get(num));
                    // 返回有循环的结果
                    return integ + "." + pre + "(" + loop + ")";
                }
                pos++;
                // 记录下当前余数和他对应小数的位置
                map.put(num, pos);
            }
            // 返回无循环有小数的结果
            return integ + "." + frac.toString();
        }
        // 返回无小数的结果
        return integ;
    }

    public static String fractionToDecimal2(int numerator, int denominator) {
        //初级优化版，参考 https://blog.csdn.net/tiaochewang219/article/details/85641972
        if (denominator == 0) {
            return "";
        }
        if (numerator == 0) {
            return "0";
        }
        //符号位单独判断-1为负，0为正
        int flag = (numerator ^ denominator) >> 31;
        //整数部分的值单独求
        long num = Math.abs((long) numerator), den = Math.abs((long) denominator);
        long Int = num / den;//整数
        long remainder = num % den;//余数
        StringBuffer res = new StringBuffer();
        res.append(flag == -1 ? "-" + Int : Int);
        if (remainder == 0) {//可以整除
            return res.toString();
        }
        //不能整除，先加一个小数点
        res.append(".");
        //小数部分单独处理，有能除尽和循环两种情况
        //是否循环通过Map对应位置来判断
        //出现循环应当是余数出现和之前相同了
        Map<Long, Long> map = new LinkedHashMap<Long, Long>();
        long div = 0;
        while (remainder != 0) {
            remainder *= 10;
            div = remainder / den;//获取商
            map.put(remainder / 10, div);//将余数和商存入
            remainder %= den;
            if (map.containsKey(remainder)) {
                //出现循环了，将所有循环数括起来
                //注意此处应当是从循环的位置括起来，而不是开头

                int fla = 0;
                for (Long key : map.keySet()) {
                    if (fla == 0 && key != remainder) {
                        res.append(map.get(key));
                    }
                    if (key == remainder) {
                        fla = 1;
                        res.append("(");
                    }
                    if (fla == 1) {
                        res.append(map.get(key));
                    }
                }
                res.append(")");
                return res.toString();
            }
        }
        for (Long key : map.keySet()) {
            res.append(map.get(key));
        }
        return res.toString();
    }

    public String fractionToDecimal1(int numerator, int denominator) {
        //初级未优化版，参考 https://blog.csdn.net/qq_41231926/article/details/86475360 易懂
        long num = numerator;//防止溢出
        long den = denominator;

        if (den == 0)
            return "";

        if (num == 0)
            return "0";

        if (den == 1)
            return num + "";

        if (den == -1)
            return String.valueOf(0 - num);

        boolean flag = false;//num与den异号标志
        if (num > 0 && den < 0) {
            flag = true;
            den = 0 - den;
        } else if (num < 0 && den > 0) {
            flag = true;
            num = 0 - num;
        } else if (num < 0 && den < 0) {
            den = 0 - den;
            num = 0 - num;
        }

        //整除的情况
        if (num > 0 && num > den && num % den == 0) {
            return (flag ? "-" : "") + String.valueOf(num / den);
        }

        long integer = num / den; //整数部分
        long remainder = num % den; //去除整数部分的余数

        StringBuilder sb = new StringBuilder();//先保存符号位、整数部分、小数点
        if (flag) {
            sb.append("-");
        }

        sb.append(integer).append(".");
        Map<Long, Long> map = new HashMap<>();//键代表的是被除数，值代表的是余数
        Set<Long> set = new HashSet<>();//存储重复的被除数
        StringBuilder decimal = new StringBuilder();//小数部分
        StringBuilder loop = new StringBuilder();//循环部分
        while (remainder != 0) {
            long c = remainder * 10;
            decimal.append(c / den);
            map.put(remainder, c % den);
            remainder = map.get(remainder);
            if (map.containsKey(remainder)) {
                if (set.contains(remainder)) {
                    break;
                } else {
                    loop.append(remainder * 10 / den);
                    set.add(remainder);
                }
            }
        }
        if (remainder != 0) {
            return sb.append(decimal.substring(0, decimal.indexOf(loop.toString()))).append("(").append(loop).append(")").toString();
        } else {
            return sb.append(decimal).toString();
        }
    }

    private void fractionToDecimalPrint(int numerator, int denominator){
        System.out.println(numerator + "/" + denominator + "=" + fractionToDecimal(numerator, denominator));
    }

    //判断a，b符号是否相同
    public static boolean isSamePositiveNegative(int a, int b){
        return (a ^ b) >> 31 == 0;
    }
```

